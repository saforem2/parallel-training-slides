[
  {
    "objectID": "index.html#forward-pass",
    "href": "index.html#forward-pass",
    "title": "Parallel Training Techniques",
    "section": "Forward Pass",
    "text": "Forward Pass\n\nEach worker has identical copy of model\nGlobal batch of data split across workers\nLoss + Grads averaged across workers before updating parameters\n\n\n\n\n\n\n    flowchart TD\n      D[\"dataset\"] --&gt; S1[\"subset_1\"]\n      D --&gt; S2[\"subset_2\"]\n      D --&gt; S3[\"subset_3\"]\n      D --&gt; S4[\"subset_4\"]\n      S1 --&gt; W1[\"Worker 1\"]\n      S2 --&gt; W2[\"Worker 2\"]\n      S3 --&gt; W3[\"Worker 3\"]\n      S4 --&gt; W4[\"Worker 4\"]"
  },
  {
    "objectID": "index.html#organization",
    "href": "index.html#organization",
    "title": "Parallel Training Techniques",
    "section": "Organization",
    "text": "Organization\n\n\n\n\n\nflowchart TD\n  subgraph identifier[\" \"]\n    direction LR\n    GPU1\n    GPU2\n    GPU3\n    GPU4\n  end\n  subgraph Network\n    direction LR\n    Model\n  end\n  Network -.-&gt; GPU1\n  Network -.-&gt; GPU2\n  Network -.-&gt; GPU3\n  Network -.-&gt; GPU4\n  subset1 --&gt; GPU1\n  subset2 --&gt; GPU2\n  subset3 --&gt; GPU3\n  subset4 --&gt; GPU4\n  subgraph Dataset\n    direction LR\n    subset1\n    subset2\n    subset3\n    subset4\n  end\n  subgraph Communication\n    direction LR\n    GPU1 &lt;-.-&gt; AR[Allreduce]\n    GPU2 &lt;-.-&gt; AR\n    GPU3 &lt;-.-&gt; AR\n    GPU4 &lt;-.-&gt; AR\n  end\n  AR ==&gt;|Broadcast| Network"
  },
  {
    "objectID": "index.html#emergent-abilities",
    "href": "index.html#emergent-abilities",
    "title": "Parallel Training Techniques",
    "section": "Emergent Abilities",
    "text": "Emergent Abilities\n\n\nEmergent abilities of Large Language Models Yao et al. (2023)"
  },
  {
    "objectID": "index.html#training-llms",
    "href": "index.html#training-llms",
    "title": "Parallel Training Techniques",
    "section": "Training LLMs",
    "text": "Training LLMs\n\n\n\n\n\n\n\n\n\nFigure 13: Visualization from Yang et al. (2023)"
  },
  {
    "objectID": "index.html#life-cycle-of-the-llm",
    "href": "index.html#life-cycle-of-the-llm",
    "title": "Parallel Training Techniques",
    "section": "Life-Cycle of the LLM",
    "text": "Life-Cycle of the LLM\n\n\n\n\nData collection + preprocessing\nPre-training\n\nArchitecture decisions:\n{model_size, hyperparameters,\nparallelism, lr_schedule, ...}\n\nSupervised Fine-Tuning\n\nInstruction Tuning\nAlignment\n\nDeploy (+ monitor, re-evaluate, etc.)\n\n\n\n\n\n\n\nPre-training: Virtually all of the compute used during pretraining phase.\n\n\nFigure 14: Figure from The Illustrated Transformer"
  },
  {
    "objectID": "index.html#forward-pass-1",
    "href": "index.html#forward-pass-1",
    "title": "Parallel Training Techniques",
    "section": "Forward Pass",
    "text": "Forward Pass\n\n\n\n\n\n\n\nFigure 15: Language Model trained for causal language modeling. Video from: 🤗 Generation with LLMs"
  },
  {
    "objectID": "index.html#generating-text",
    "href": "index.html#generating-text",
    "title": "Parallel Training Techniques",
    "section": "Generating Text",
    "text": "Generating Text\n\n\n\n\n\n\n\nFigure 16: Language Model trained for causal language modeling. Video from: 🤗 Generation with LLMs"
  },
  {
    "objectID": "index.html#life-cycle-of-the-llm-pre-training",
    "href": "index.html#life-cycle-of-the-llm-pre-training",
    "title": "Parallel Training Techniques",
    "section": "Life-Cycle of the LLM: Pre-training",
    "text": "Life-Cycle of the LLM: Pre-training\n\n\nFigure 17: Pre-training: Virtually all of the compute used during pretraining phase"
  },
  {
    "objectID": "index.html#life-cycle-of-the-llm-fine-tuning",
    "href": "index.html#life-cycle-of-the-llm-fine-tuning",
    "title": "Parallel Training Techniques",
    "section": "Life-Cycle of the LLM: Fine-Tuning",
    "text": "Life-Cycle of the LLM: Fine-Tuning\n\n\n\n\n\n\nFigure 18: Fine-tuning1: Fine-tuning actually updates the model’s weights to make the model better at a certain task.\n\n\n\nFigure from The Illustrated Transformer"
  },
  {
    "objectID": "index.html#assistant-models",
    "href": "index.html#assistant-models",
    "title": "Parallel Training Techniques",
    "section": "Assistant Models",
    "text": "Assistant Models"
  },
  {
    "objectID": "index.html#saforem2wordplay",
    "href": "index.html#saforem2wordplay",
    "title": "Parallel Training Techniques",
    "section": "saforem2/wordplay 🎮💬",
    "text": "saforem2/wordplay 🎮💬\n\n\nFork of Andrej Karpathy’s nanoGPT\n\n\n\nFigure 19: The simplest, fastest repository for training / finetuning GPT based models."
  },
  {
    "objectID": "index.html#saforem2wordplay-1",
    "href": "index.html#saforem2wordplay-1",
    "title": "Parallel Training Techniques",
    "section": "saforem2/wordplay 🎮💬",
    "text": "saforem2/wordplay 🎮💬\n\n\n\n\n\n\n\n\n\n\n\n(a) nanoGPT\n\n\n\n\n\n\n\n\n\n\n\n(b) wordplay 🎮 💬\n\n\n\n\n\n\n\nFigure 20: nanoGPT, transformed."
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "Parallel Training Techniques",
    "section": "Install",
    "text": "Install\npython3 -m pip install \"git+https://github.com/saforem2/wordplay.git\"\npython3 -c 'import wordplay; print(wordplay.__file__)'\n# ./wordplay/src/wordplay/__init__.py"
  },
  {
    "objectID": "index.html#dependencies",
    "href": "index.html#dependencies",
    "title": "Parallel Training Techniques",
    "section": "Dependencies",
    "text": "Dependencies\n\ntransformers for  transformers (to load GPT-2 checkpoints)\ndatasets for  datasets (if you want to use OpenWebText)\ntiktoken for OpenAI’s fast BPE code\nwandb for optional logging\ntqdm for progress bars"
  },
  {
    "objectID": "index.html#quick-start",
    "href": "index.html#quick-start",
    "title": "Parallel Training Techniques",
    "section": "Quick Start",
    "text": "Quick Start\n\nWe start with training a character-level GPT on the works of Shakespeare.\n\nDownloading the data (~ 1MB) file\nConvert raw text to one large stream of integers\n\npython3 data/shakespeare_char/prepare.py\nThis will create data/shakespeare_char/{train.bin, val.bin}."
  },
  {
    "objectID": "index.html#model-model.py",
    "href": "index.html#model-model.py",
    "title": "Parallel Training Techniques",
    "section": "Model  model.py",
    "text": "Model  model.py\n\nCausalSelfAttentionLayerNormMLPBlockGPT\n\n\nclass CausalSelfAttention(nn.Module):\n    def __init__(self, config: GPTModelConfig):\n        super().__init__()\n        assert config.n_embd % config.n_head == 0\n        # key, query, value projections for all heads, but in a batch\n        self.c_attn = nn.Linear(\n            config.n_embd,\n            3 * config.n_embd,\n            bias=config.bias\n        )\n        # output projection\n        self.c_proj = nn.Linear(\n            config.n_embd,\n            config.n_embd,\n            bias=config.bias\n        )\n        # regularization\n        self.attn_dropout = nn.Dropout(config.dropout)\n        self.resid_dropout = nn.Dropout(config.dropout)\n        self.n_head = config.n_head\n        self.n_embd = config.n_embd\n        self.dropout = config.dropout\n        # flash attention make GPU go brrrrr but support is only in\n        # PyTorch &gt;= 2.0\n        self.flash = hasattr(\n            torch.nn.functional,\n            'scaled_dot_product_attention'\n        )\n        # if self.flash and RANK == 0:\n        #     log.warning(\n        #         f'Using torch.nn.functional.scaled_dot_product_attention'\n        #         '(Flash Attn)'\n        #     )\n        if not self.flash:\n            log.warning(\n                \"WARNING: using slow attention.\"\n                \"Flash Attention requires PyTorch &gt;= 2.0\"\n            )\n            # causal mask to ensure that attention is only applied to the left\n            # in the input sequence\n            self.register_buffer(\n                \"bias\",\n                torch.tril(\n                    torch.ones(\n                        config.block_size,\n                        config.block_size\n                    )\n                ).view(1, 1, config.block_size, config.block_size)\n            )\n\n    def forward(self, x):\n        # batch size, sequence length, embedding dimensionality (n_embd)\n        B, T, C = x.size()\n\n        # calculate query, key, values for all heads in batch and move head\n        # forward to be the batch dim\n        q, k, v = self.c_attn(x).split(self.n_embd, dim=2)\n        # (B, nh, T, hs)\n        k = k.view(B, T, self.n_head, C // self.n_head).transpose(1, 2)\n        # (B, nh, T, hs)\n        q = q.view(B, T, self.n_head, C // self.n_head).transpose(1, 2)\n        # (B, nh, T, hs)\n        v = v.view(B, T, self.n_head, C // self.n_head).transpose(1, 2)\n        # causal self-attention; Self-attend:\n        # (B, nh, T, hs) x (B, nh, hs, T) -&gt; (B, nh, T, T)\n        if self.flash:\n            # efficient attention using Flash Attention CUDA kernels\n            y = torch.nn.functional.scaled_dot_product_attention(\n                q,\n                k,\n                v,\n                attn_mask=None,\n                dropout_p=(self.dropout if self.training else 0),\n                is_causal=True\n            )\n        else:\n            # manual implementation of attention\n            att = (q @ k.transpose(-2, -1)) * (1.0 / math.sqrt(k.size(-1)))\n            att = att.masked_fill(\n                self.bias[:, :, :T, :T] == 0,  # type:ignore\n                float('-inf')\n            )\n            att = F.softmax(att, dim=-1)\n            att = self.attn_dropout(att)\n            y = att @ v  # (B, nh, T, T) x (B, nh, T, hs) -&gt; (B, nh, T, hs)\n        # re-assemble all head outputs side by side\n        y = y.transpose(1, 2).contiguous().view(B, T, C)\n\n        # output projection\n        y = self.resid_dropout(self.c_proj(y))\n        return y\n\n\nclass LayerNorm(nn.Module):\n    \"\"\"\n    LayerNorm but with an optional bias.\n\n    (PyTorch doesn't support simply bias=False)\n    \"\"\"\n\n    def __init__(self, ndim, bias):\n        super().__init__()\n        self.weight = nn.Parameter(torch.ones(ndim))\n        self.bias = nn.Parameter(torch.zeros(ndim)) if bias else None\n\n    def forward(self, input):\n        return F.layer_norm(\n            input,\n            self.weight.shape,\n            self.weight,\n            self.bias,\n            1e-5\n        )\n\n\nclass MLP(nn.Module):\n\n    def __init__(\n            self,\n            config: GPTModelConfig,\n            activation: str = 'gelu',\n    ):\n        super().__init__()\n        self.c_fc = nn.Linear(\n            config.n_embd,\n            4 * config.n_embd,\n            bias=config.bias\n        )\n        if activation.lower() in ACTIVATIONS:\n            self.act_fn = ACTIVATIONS[activation.lower()]\n        else:\n            try:\n                act_fn = getattr(nn, activation)\n                assert callable(act_fn)\n                self.act_fn = act_fn()\n            except Exception as exc:\n                log.error(f'{activation} not yet supported!')\n                raise exc\n        # self.gelu = nn.GELU()\n        self.c_proj = nn.Linear(\n            4 * config.n_embd,\n            config.n_embd,\n            bias=config.bias\n        )\n        self.dropout = nn.Dropout(config.dropout)\n\n    def forward(self, x):\n        x = self.c_fc(x)\n        # x = self.gelu(x)\n        x = self.act_fn(x)\n        x = self.c_proj(x)\n        x = self.dropout(x)\n        return x\n\n\nclass Block(nn.Module):\n\n    def __init__(self, config: GPTModelConfig):\n        super().__init__()\n        self.ln_1 = LayerNorm(config.n_embd, bias=config.bias)\n        self.attn = CausalSelfAttention(config)\n        self.ln_2 = LayerNorm(config.n_embd, bias=config.bias)\n        self.mlp = MLP(config)\n\n    def forward(self, x):\n        x = x + self.attn(self.ln_1(x))\n        x = x + self.mlp(self.ln_2(x))\n        return x\n\n\nclass GPT(nn.Module):\n    def __init__(self, config: GPTModelConfig):\n        super().__init__()\n        assert config.vocab_size is not None\n        assert config.block_size is not None\n        self.config = config\n\n        self.transformer = nn.ModuleDict(dict(\n            wte=nn.Embedding(config.vocab_size, config.n_embd),\n            wpe=nn.Embedding(config.block_size, config.n_embd),\n            drop=nn.Dropout(config.dropout),\n            h=nn.ModuleList([Block(config) for _ in range(config.n_layer)]),\n            ln_f=LayerNorm(config.n_embd, bias=config.bias),\n        ))\n        self.lm_head = nn.Linear(config.n_embd, config.vocab_size, bias=False)\n        # with weight tying when using torch.compile() some warnings get\n        # generated: \"UserWarning: functional_call was passed multiple values\n        # for tied weights. This behavior is deprecated and will be an error in\n        # future versions\" not 100% sure what this is, so far seems to be\n        # harmless. TODO investigate\n        # https://paperswithcode.com/method/weight-tying\n        self.transformer.wte.weight = self.lm_head.weight  # type:ignore\n\n        # init all weights\n        self.apply(self._init_weights)\n        # apply special scaled init to the residual projections, per GPT-2\n        for pn, p in self.named_parameters():\n            if pn.endswith('c_proj.weight'):\n                torch.nn.init.normal_(\n                    p,\n                    mean=0.0,\n                    std=0.02/math.sqrt(2 * config.n_layer)\n                )\n\n        # report number of parameters\n        log.info(\"number of parameters: %.2fM\" % (self.get_num_params()/1e6,))\n\n    def get_num_params(self, non_embedding=True):\n        \"\"\"\n        Return the number of parameters in the model.\n        For non-embedding count (default), the position embeddings get\n        subtracted.\n\n        The token embeddings would too, except due to the parameter sharing\n        these params are actually used as weights in the final layer, so we\n        include them.\n        \"\"\"\n        n_params = sum(p.numel() for p in self.parameters())\n        if non_embedding:\n            n_params -= self.transformer.wpe.weight.numel()  # type:ignore\n        return n_params\n\n    def _init_weights(self, module):\n        if isinstance(module, nn.Linear):\n            torch.nn.init.normal_(module.weight, mean=0.0, std=0.02)\n            if module.bias is not None:\n                torch.nn.init.zeros_(module.bias)\n        elif isinstance(module, nn.Embedding):\n            torch.nn.init.normal_(module.weight, mean=0.0, std=0.02)\n\n    def forward(self, idx, targets=None):\n        device = idx.device\n        b, t = idx.size()\n        assert t &lt;= self.config.block_size, (\n            f\"Cannot forward sequence of length {t}, \"\n            \"block size is only {self.config.block_size}\"\n        )\n        pos = torch.arange(\n            0,\n            t,\n            dtype=torch.long,\n            device=device\n        )  # shape (t)\n\n        # forward the GPT model itself\n        # token embeddings of shape (b, t, n_embd)\n        tok_emb = self.transformer.wte(idx)  # type:ignore\n        # position embeddings of shape (t, n_embd)\n        pos_emb = self.transformer.wpe(pos)  # type:ignore\n        x = self.transformer.drop(tok_emb + pos_emb)  # type:ignore\n        for block in self.transformer.h:  # type:ignore\n            x = block(x)\n        x = self.transformer.ln_f(x)  # type:ignore\n        if targets is not None:\n            # if we are given some desired targets also calculate the loss\n            logits = self.lm_head(x)\n            loss = F.cross_entropy(\n                logits.view(\n                    -1,\n                    logits.size(-1)\n                ),\n                targets.view(-1),\n                ignore_index=-1\n            )\n        else:\n            # inference-time mini-optimization: only forward the lm_head on the\n            # very last position\n            # note: using list [-1] to preserve the time dim\n            logits = self.lm_head(x[:, [-1], :])\n            loss = None\n\n        return logits, loss\n\n    def crop_block_size(self, block_size):\n        # model surgery to decrease the block size if necessary e.g. we may\n        # load the GPT2 pretrained model checkpoint (block size 1024) but want\n        # to use a smaller block size for some smaller, simpler model\n        assert block_size &lt;= self.config.block_size\n        self.config.block_size = block_size\n        self.transformer.wpe.weight = (  # type:ignore\n            nn.Parameter(\n                self.transformer.wpe.weight[:block_size]  # type:ignore\n            )\n        )\n        for block in self.transformer.h:   # type:ignore\n            if hasattr(block.attn, 'bias'):\n                block.attn.bias = (\n                    block.attn.bias[:, :, :block_size, :block_size]\n                )\n\n    @classmethod\n    def from_pretrained(cls, model_type, override_args=None):\n        assert model_type in {'gpt2', 'gpt2-medium', 'gpt2-large', 'gpt2-xl'}\n        override_args = override_args or {}  # default to empty dict\n        # only dropout can be overridden see more notes below\n        assert all(k == 'dropout' for k in override_args)\n        from transformers import GPT2LMHeadModel\n        log.info(f\"loading weights from pretrained gpt: {model_type=}\")\n        # n_layer, n_head and n_embd are determined from model_type\n        # gpt2: 124M params\n        # gpt2-medium: 350M params\n        # gpt2-large: 774M params\n        # gpt2-xl: 1558M params\n        config_args = {\n            # 'baby-llama2': dict(n_layer=16, n_head=16, n_embed=1024),\n            # 'llama2-7b': dict(n_layer=32, n_head=32, n_embd=4096),\n            'gpt2': dict(n_layer=12, n_head=12, n_embd=768),\n            'gpt2-medium': dict(n_layer=24, n_head=16, n_embd=1024),\n            'gpt2-large': dict(n_layer=36, n_head=20, n_embd=1280),\n            'gpt2-xl': dict(n_layer=48, n_head=25, n_embd=1600),\n        }[model_type]\n        # we can override the dropout rate, if desired\n        if 'dropout' in override_args:\n            log.info(f\"overriding dropout rate to {override_args['dropout']}\")\n            config_args['dropout'] = override_args['dropout']\n        # create a from-scratch initialized minGPT model\n        log.info(\"forcing vocab_size=50257, block_size=1024, bias=True\")\n        config = GPTModelConfig(\n            **config_args,\n            block_size=1024,   # always 1024 for GPT model checkpoints\n            vocab_size=50257,  # always 50257 for GPT model checkpoints\n            bias=True,         # always True for GPT model checkpoints\n        )\n        model = GPT(config)\n        sd = model.state_dict()\n        sd_keys = sd.keys()\n        sd_keys = [\n            k for k in sd_keys if not k.endswith('.attn.bias')\n        ]  # discard this mask / buffer, not a param\n\n        # init a huggingface/transformers model\n        model_hf = GPT2LMHeadModel.from_pretrained(model_type)\n        sd_hf = model_hf.state_dict()\n\n        # copy while ensuring all of the parameters are aligned and match in\n        # names and shapes\n        sd_keys_hf = sd_hf.keys()\n        sd_keys_hf = [\n            k for k in sd_keys_hf if not k.endswith('.attn.masked_bias')\n        ]  # ignore these, just a buffer\n        sd_keys_hf = [\n            k for k in sd_keys_hf if not k.endswith('.attn.bias')\n        ]  # same, just the mask (buffer)\n        transposed = [\n            'attn.c_attn.weight',\n            'attn.c_proj.weight',\n            'mlp.c_fc.weight',\n            'mlp.c_proj.weight'\n        ]\n        # basically the openai checkpoints use a \"Conv1D\" module, but we only\n        # want to use a vanilla Linear this means that we have to transpose\n        # these weights when we import them\n        assert len(sd_keys_hf) == len(sd_keys), (\n            f\"mismatched keys: {len(sd_keys_hf)} != {len(sd_keys)}\"\n        )\n        for k in sd_keys_hf:\n            if any(k.endswith(w) for w in transposed):\n                # special treatment for the Conv1D weights we need to transpose\n                assert sd_hf[k].shape[::-1] == sd[k].shape\n                with torch.no_grad():\n                    sd[k].copy_(sd_hf[k].t())\n            else:\n                # vanilla copy over the other parameters\n                assert sd_hf[k].shape == sd[k].shape\n                with torch.no_grad():\n                    sd[k].copy_(sd_hf[k])\n\n        return model\n\n    def configure_optimizers(\n            self,\n            weight_decay,\n            learning_rate,\n            betas,\n            device_type\n    ):\n        # start with all of the candidate parameters\n        # filter out those that do not require grad\n        # param_dict = {\n        #     pn: p for pn, p in param_dict.items() if p.requires_grad\n        # }\n        param_dict = {\n            pn: p for pn, p in self.named_parameters() if p.requires_grad\n        }\n        # create optim groups. Any parameters that is 2D will be weight\n        # decayed, otherwise no. i.e. all weight tensors in matmuls +\n        # embeddings decay, all biases and layernorms don't.\n        decay_params = [p for _, p in param_dict.items() if p.dim() &gt;= 2]\n        nodecay_params = [p for _, p in param_dict.items() if p.dim() &lt; 2]\n        optim_groups = [\n            {'params': decay_params, 'weight_decay': weight_decay},\n            {'params': nodecay_params, 'weight_decay': 0.0}\n        ]\n        num_decay_params = sum(p.numel() for p in decay_params)\n        num_nodecay_params = sum(p.numel() for p in nodecay_params)\n        log.info(\n            f\"num decayed parameter tensors: {len(decay_params)}, \"\n            f\"with {num_decay_params:,} parameters\"\n        )\n        log.info(\n            f\"num non-decayed parameter tensors: {len(nodecay_params)}, \"\n            f\"with {num_nodecay_params:,} parameters\"\n        )\n        # Create AdamW optimizer and use the fused version if it is available\n        fused_available = (\n            'fused' in inspect.signature(torch.optim.AdamW).parameters\n        )\n        use_fused = fused_available and device_type == 'cuda'\n        extra_args = dict(fused=True) if use_fused else {}\n        optimizer = torch.optim.AdamW(\n            optim_groups,\n            lr=learning_rate,\n            betas=betas,\n            **extra_args\n        )\n        log.info(f\"using fused AdamW: {use_fused}\")\n\n        return optimizer\n\n    def estimate_mfu(self, fwdbwd_per_iter, dt):\n        \"\"\"Estimate model flops utilization (MFU)\n\n        (in units of A100 bfloat16 peak FLOPS)\n        \"\"\"\n        # first estimate the number of flops we do per iteration.\n        # see PaLM paper Appendix B as ref: https://arxiv.org/abs/2204.02311\n        N = self.get_num_params()\n        cfg = self.config\n        L, H, Q, T = (\n            cfg.n_layer,\n            cfg.n_head,\n            cfg.n_embd//cfg.n_head,\n            cfg.block_size\n        )\n        flops_per_token = 6*N + 12*L*H*Q*T\n        flops_per_fwdbwd = flops_per_token * T\n        flops_per_iter = flops_per_fwdbwd * fwdbwd_per_iter\n        # express our flops throughput as ratio of A100 bfloat16 peak flops\n        flops_achieved = flops_per_iter * (1.0/dt)  # per second\n        flops_promised = 312e12  # A100 GPU bfloat16 peak flops is 312 TFLOPS\n        return flops_achieved / flops_promised\n\n    @torch.no_grad()\n    def generate(self, idx, max_new_tokens, temperature=1.0, top_k=None):\n        \"\"\"\n        Take a conditioning sequence of indices idx (LongTensor of shape (b,t))\n        and complete the sequence max_new_tokens times, feeding the predictions\n        back into the model each time.\n\n        Most likely you'll want to make sure to be in model.eval() mode of\n        operation for this.\n        \"\"\"\n        for _ in range(max_new_tokens):\n            # if the sequence context is growing too long we must crop it at\n            # block_size\n            idx_cond = (\n                idx if idx.size(1) &lt;= self.config.block_size\n                else idx[:, -self.config.block_size:]\n            )\n            # forward the model to get the logits for the index in the sequence\n            logits, _ = self(idx_cond)\n            # pluck the logits at the final step and scale by desired\n            # temperature\n            logits = logits[:, -1, :] / temperature\n            # optionally crop the logits to only the top k options\n            if top_k is not None:\n                v, _ = torch.topk(logits, min(top_k, logits.size(-1)))\n                logits[logits &lt; v[:, [-1]]] = -float('Inf')\n            # apply softmax to convert logits to (normalized) probabilities\n            probs = F.softmax(logits, dim=-1)\n            # sample from the distribution\n            idx_next = torch.multinomial(probs, num_samples=1)\n            # append sampled index to the running sequence and continue\n            idx = torch.cat((idx, idx_next), dim=1)\n\n        return idx"
  },
  {
    "objectID": "index.html#trainer-trainer.py",
    "href": "index.html#trainer-trainer.py",
    "title": "Parallel Training Techniques",
    "section": "Trainer  trainer.py",
    "text": "Trainer  trainer.py\n\nget_batch_forward_step_backward_steptrain_stepestimate_loss\n\n\n    def get_batch(self, split: str) -&gt; tuple[torch.Tensor, torch.Tensor]:\n        # data = self.config.train_data if split == 'train'\n        # else self.config.val_data\n        data = self.config.data.data.get(split, None)\n        assert data is not None\n        ix = torch.randint(\n            len(data) - self.config.model.block_size,\n            (self.config.model.batch_size,)\n        )\n        block_size = self.config.model.block_size\n        x = torch.stack(\n            [\n                torch.from_numpy((data[i:i+block_size]).astype(np.int64))\n                for i in ix\n            ]\n        )\n        y = torch.stack(\n            [\n                torch.from_numpy((data[i+1:i+1+block_size]).astype(np.int64))\n                for i in ix\n            ]\n        )\n        if self.config.device_type == 'cuda':\n            x = x.pin_memory().to(self.config.device_type, non_blocking=True)\n            y = y.pin_memory().to(self.config.device_type, non_blocking=True)\n        else:\n            x = x.to(self.config.device_type)\n            y = y.to(self.config.device_type)\n        return x, y\n\n\n    def _forward_step(self, x: torch.Tensor, y: torch.Tensor) -&gt; dict:\n        t0 = time.perf_counter()\n        with self.config.ctx:\n            logits, loss = self.model_engine(x, y)\n        return {\n            'logits': logits,\n            'loss': loss,\n            'dt': time.perf_counter() - t0\n        }\n\n\n    def _backward_step(\n            self,\n            loss: torch.Tensor,\n            propagate_grads: bool = False,\n    ) -&gt; float:\n        t0 = time.perf_counter()\n        if self.config.train.backend.lower() in ['ds', 'deepspeed']:\n            self.model_engine.backward(loss)  # type:ignore\n            self.model_engine.step(loss)      # type:ignore\n        else:\n            if self.grad_scaler is not None:\n                self.grad_scaler.scale(loss).backward()  # type:ignore\n            if propagate_grads:\n                if self.config.optimizer.grad_clip != 0.0:\n                    if self.grad_scaler is not None:\n                        self.grad_scaler.unscale_(self.optimizer)\n                    torch.nn.utils.clip_grad_norm_(  # pyright: ignore\n                        self.model_engine.parameters(),\n                        self.config.optimizer.grad_clip\n                    )\n                if self.grad_scaler is not None:\n                    self.grad_scaler.step(self.optimizer)\n                    self.grad_scaler.update()\n                    self.optimizer.zero_grad(set_to_none=True)\n\n        return time.perf_counter() - t0\n\n\n    def train_step(\n            self,\n            x: torch.Tensor,\n            y: torch.Tensor,\n    ) -&gt; dict:\n        lr = (\n            self.get_lr(self.config.iter_num)\n            if self.config.optimizer.decay_lr\n            else self._lr\n        )\n        for param_group in self.optimizer.param_groups:\n            param_group['lr'] = lr\n        dtf = []\n        dtb = []\n        dt = []\n        loss = torch.tensor(0.0)\n        for micro_step in range(self._gas):\n            is_last_micro_step = (micro_step == self._gas - 1)\n            # NOTE: -----------------------------------------------------------\n            # In DDP training we only need to sync gradients at the last micro\n            # step. the official way to do this is with model.no_sync() context\n            # manager, but I really dislike that this bloats the code and\n            # forces us to repeat code looking at the source of that context\n            # manager, it just toggles this variable\n            # -----------------------------------------------------------------\n            if self.config.train.backend.lower() == 'ddp':\n                _ = (\n                    self.model_engine.require_backward_grad_sync\n                    if (is_last_micro_step and self.world_size &gt; 1)\n                    else None\n                )\n            fout = self._forward_step(x, y)\n            # immediately async prefetch next batch while model is doing the\n            # forward pass on the GPU\n            x, y = self.get_batch('train')\n            loss = fout['loss'] / self._gas\n            dtf.append(fout['dt'])\n            dtb_ = self._backward_step(\n                loss,\n                propagate_grads=is_last_micro_step\n            )\n            dtb.append(dtb_)\n            dt.append(dtf + dtb)\n        timers = {\n            'iter': self.config.iter_num,\n            'dt': np.array(dt),\n            'dt_tot': np.sum(dt),\n            'dt_avg': np.mean(dt),\n            'dtf': np.array(dtf),\n            'dtf_tot': np.sum(dtf),\n            'dtf_avg': np.mean(dtf),\n            'dtb': np.array(dtb),\n            'dtb_tot': np.sum(dtb),\n            'dtb_avg': np.mean(dtb)\n        }\n        metrics = {\n            'iter': self.config.iter_num,\n            'loss': loss,\n            'lr': lr,\n        }\n        self.config.iter_num += 1\n        return {\n            'metrics': metrics,\n            'timers': timers,\n            'x': x,\n            'y': y,\n        }\n\n\n    @torch.no_grad()\n    def estimate_loss(self):\n        out = {}\n        self.model.eval()\n        for split in self.config.data.data.keys():\n            losses = torch.zeros(self.config.train.eval_iters)\n            for k in range(self.config.train.eval_iters):\n                x, y = self.get_batch(split)\n                with self.config.ctx:\n                    _, loss = self.model_engine(x, y)\n                losses[k] = loss.item()\n            out[split] = losses.mean()\n        self.model.train()\n        return out"
  },
  {
    "objectID": "index.html#self-contained-shakespeare-example",
    "href": "index.html#self-contained-shakespeare-example",
    "title": "Parallel Training Techniques",
    "section": "Self-Contained Shakespeare Example",
    "text": "Self-Contained Shakespeare Example\n\n\n\n\n📒 Shakespeare🔗 Links\n\n\n\n\n\nshakespeare.ipynb\n\n\n\n\n📊 Slides\n🏡 Project Website\n💻 saforem2/wordplay"
  },
  {
    "objectID": "index.html#links-1",
    "href": "index.html#links-1",
    "title": "Parallel Training Techniques",
    "section": "Links",
    "text": "Links\n\n Hannibal046/Awesome-LLM \n Mooler0410/LLMsPracticalGuide\nLarge Language Models (in 2023)\nThe Illustrated Transformer\nGenerative AI Exists because of the Transformer\nGPT in 60 Lines of Numpy\nBetter Language Models and their Implications\n\n Progress / Artefacts / Outcomes from 🌸 Bloom BigScience\n\n\n\n\n\n\n\n\nAcknowledgements\n\n\nThis research used resources of the Argonne Leadership Computing Facility,\nwhich is a DOE Office of Science User Facility supported under Contract DE-AC02-06CH11357."
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "Parallel Training Techniques",
    "section": "References",
    "text": "References\n\nDeepSpeed: Extreme-scale model training for everyone - Microsoft Research\nNVIDIA / NCCL / Collective Operations\n\n\n\nYang, Jingfeng, Hongye Jin, Ruixiang Tang, Xiaotian Han, Qizhang Feng, Haoming Jiang, Bing Yin, and Xia Hu. 2023. “Harnessing the Power of LLMs in Practice: A Survey on ChatGPT and Beyond.” https://arxiv.org/abs/2304.13712.\n\n\nYao, Shunyu, Dian Yu, Jeffrey Zhao, Izhak Shafran, Thomas L. Griffiths, Yuan Cao, and Karthik Narasimhan. 2023. “Tree of Thoughts: Deliberate Problem Solving with Large Language Models.” https://arxiv.org/abs/2305.10601."
  }
]